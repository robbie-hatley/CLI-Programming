#! /usr/bin/perl

# This is a 120-character-wide UTF-8 Unicode Perl source-code text file with hard Unix line breaks ("\x{0A}").
# ¡Hablo Español! Говорю Русский. Björt skjöldur. ॐ नमो भगवते वासुदेवाय. 看的星星，知道你是爱。 麦藁雪、富士川町、山梨県。
# =======|=========|=========|=========|=========|=========|=========|=========|=========|=========|=========|=========|

########################################################################################################################
# RH::WinChomp.pm
# WinChomp contains functions which add, remove, or alter line endings and BOM markers, especially in files
# generated by the Microsoft Windows operating system or its utilities, which tend to use "\x0D0A" as
# "newline".
#
# If no argument is supplied, these functions alter $_ and return $_ .
#
# If an argument *is* supplied, these functions will alter a copy of the
# argument and return the altered copy; the original argument is not altered.
#
# If you want to make the functions return other things (number of characters
# added or removed, for example) feel free to alter them at will.
#
# This module uses no package variables (other than builtins).
# None of the subs depend on each other, so there are no pre-declarations.
# None of the subs use prototypes.
# Copyleft 2015, Robbie Hatley. No rights reserved. Use as you please.
#
# Edit history:
# Some time in 2015:
#    Wrote it.
# Sun Dec 31, 2017:
#    use 5.026_001. use Exporter.
# Tue Jun 05, 2018: use v5.20
# Sat Nov 20, 2021: use v5.32. Renewed colophon. Revamped pragmas & encodings.
# Thu Oct 03, 2024: Got rid of Sys::Binmode.
########################################################################################################################

# Package:
package RH::WinChomp;

# Pragmas:
use v5.32;
use strict;
use warnings;
use experimental 'switch';
use utf8;
use warnings FATAL => 'utf8';

# Encodings:
use open ':std', IN  => ':encoding(UTF-8)';
use open ':std', OUT => ':encoding(UTF-8)';
use open         IN  => ':encoding(UTF-8)';
use open         OUT => ':encoding(UTF-8)';
# NOTE: these may be over-ridden later. Eg, "open($fh, '< :raw', e $path)".

# CPAN modules:
use parent 'Exporter';

# Symbols exported by default:
our @EXPORT = qw( winchomp remove_bom );

# Symbols which may be exported by-request:
our %EXPORT_TAGS =
(
   esoteric => [qw(line_ends_to_unix   line_ends_to_windows   line_ends_to_oldmac
                   add_unix_newline    add_windows_newline    add_oldmac_newline       )]
);
Exporter::export_ok_tags('esoteric');

# Remove any cluster of \x0d and/or \x0a characters from line end:
sub winchomp
{
   if (@_)
   {
      my $text = shift;
      $text =~ s/[\x0a\x0d]+$//;
      return $text;
   }
   else
   {
      s/[\x0a\x0d]+$//;
      return $_;
   }
}

# Remove a BOM mark from the beginning of a line. NOTE: while a BOM mark
# in a utf-8 file is "EF BB BF" as the first 3 bytes of the file, in Perl's
# memory a BOM mark is the 2-byte sequence "FEFF". This is because
# "EF BB BF" is the utf8 encoding of the Unicode "BOM" character,
# which is actually \N{U+FEFF}, or \N{BOM} for short.
sub remove_bom
{
   if (@_)
   {
      my $text = shift;
      $text =~ s/^\N{BOM}//;
      return $text;
   }
   else
   {
      s/^\N{BOM}//;
      return $_;
   }
}

# Convert any cluster of \x0d and/or \x0a characters at line end to \x0a:
sub line_ends_to_unix
{
   if (@_)
   {
      my $text = shift;
      $text =~ s/[\x0a\x0d]+$/\x0a/;
      return $text;
   }
   else
   {
      s/[\x0a\x0d]+$/\x0a/;
      return $_;
   }
}

# Convert any cluster of \x0d and/or \x0a characters at line end to \x0d\x0a:
sub line_ends_to_windows
{
   if (@_)
   {
      my $text = shift;
      $text =~ s/[\x0a\x0d]+$/\x0d\x0a/;
      return $text;
   }
   else
   {
      s/[\x0a\x0d]+$/\x0d\x0a/;
      return $_;
   }
}

# Convert any cluster of \x0d and/or \x0a characters at line end to \x0d:
sub line_ends_to_oldmac
{
   if (@_)
   {
      my $text = shift;
      $text =~ s/[\x0a\x0d]+$/\x0d/;
      return $text;
   }
   else
   {
      s/[\x0a\x0d]+$/\x0d/;
      return $_;
   }
}

# Tack a Unix endline on end of line.
sub add_unix_newline
{
   if (@_)
   {
      my $text = shift;
      $text .= "\x0a";
      return $text;
   }
   else
   {
      $_ .= "\x0a";
      return $_;
   }
}

# Tack a Windows endline on end of line.
sub add_windows_newline
{
   if (@_)
   {
      my $text = shift;
      $text .= "\x0d\x0a";
      return $text;
   }
   else
   {
      $_ .= "\x0d\x0a";
      return $_;
   }
}

# Tack an Old-Mac endline on end of line.
sub add_oldmac_newline
{
   if (@_)
   {
      my $text = shift;
      $text .= "\x0d";
      return $text;
   }
   else
   {
      $_ .= "\x0d";
      return $_;
   }
}

1;
